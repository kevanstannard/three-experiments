/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/experiments/slides/index.js":
/*!*****************************************!*\
  !*** ./src/experiments/slides/index.js ***!
  \*****************************************/
/***/ (() => {

eval("var SCREEN_WIDTH = window.innerWidth;\nvar SCREEN_HEIGHT = window.innerHeight;\nvar VIEW_ANGLE = 45;\nvar ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT;\nvar NEAR = 1;\nvar FAR = 10000;\nvar scene;\nvar camera;\nvar renderer;\n// let orbitControls;\nvar keyboard;\nvar axis;\nvar animateDirection = 0;\nvar animateRotation = 0;\nvar materialFront;\nvar materialRight;\nvar materialBack;\nvar materialLeft;\nvar SPEED = Math.PI / 2 / 60;\nvar PLANE_WIDTH = 180;\nvar PLANE_HEIGHT = 100;\nvar DISTANCE = 100;\nvar key = {\n    FORWARD: \"W\",\n    BACKWARD: \"S\",\n    LEFT: \"A\",\n    RIGHT: \"D\",\n    UP: \"space\",\n    DOWN: \"shift\"\n};\nvar slides = [\n    \"../../assets/textures/slides/broccoli.jpg\",\n    \"../../assets/textures/slides/carrots.jpg\",\n    \"../../assets/textures/slides/cauliflower.jpg\",\n    \"../../assets/textures/slides/onions.jpg\",\n    \"../../assets/textures/slides/pumpkin.jpg\", \n];\nvar textureLoader = new THREE.TextureLoader();\nvar textures = slides.map(function(slide) {\n    return textureLoader.load(slide);\n});\nvar nextTexture = 0;\nvar currentTexture = 0;\nvar indexAt = function(index) {\n    if (index < 0) {\n        return (textures.length - -index % textures.length) % textures.length;\n    }\n    return index % textures.length;\n};\nvar textureAt = function(index) {\n    return textures[indexAt(index)];\n};\nfunction init() {\n    keyboard = new KeyboardState();\n    scene = new THREE.Scene();\n    camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);\n    camera.position.set(200, 200, 200);\n    camera.lookAt(new THREE.Vector3());\n    // camera.position.set(0, 0, DISTANCE - 10);\n    renderer = new THREE.WebGLRenderer({\n        antialias: true\n    });\n    renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);\n    // orbitControls = new THREE.OrbitControls(camera, renderer.domElement);\n    THREEx.WindowResize(renderer, camera);\n    document.body.appendChild(renderer.domElement);\n    // const gridHelper = new THREE.GridHelper(100, 10);\n    // scene.add(gridHelper);\n    // const axisHelper = new THREE.AxisHelper(100);\n    // scene.add(axisHelper);\n    // const markerGeometry = new THREE.SphereGeometry(5);\n    // const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });\n    // const marker = new THREE.Mesh(markerGeometry, markerMaterial);\n    // marker.position.setY(60);\n    axis = new THREE.Object3D();\n    var geometry = new THREE.PlaneGeometry(PLANE_WIDTH, PLANE_HEIGHT);\n    var textureFront = textureAt(0);\n    materialFront = new THREE.MeshBasicMaterial({\n        map: textureFront,\n        side: THREE.DoubleSide\n    });\n    var planeFront = new THREE.Mesh(geometry, materialFront);\n    // planeFront.add(marker);\n    planeFront.position.setZ(-DISTANCE);\n    axis.add(planeFront);\n    var textureRight = textureAt(1);\n    materialRight = new THREE.MeshBasicMaterial({\n        map: textureRight,\n        side: THREE.DoubleSide\n    });\n    var planeRight = new THREE.Mesh(geometry, materialRight);\n    planeRight.position.setX(DISTANCE);\n    planeRight.rotateY(-Math.PI / 2);\n    axis.add(planeRight);\n    var textureLeft = textureAt(-1);\n    materialLeft = new THREE.MeshBasicMaterial({\n        map: textureLeft,\n        side: THREE.DoubleSide\n    });\n    var planeLeft = new THREE.Mesh(geometry, materialLeft);\n    planeLeft.position.setX(-DISTANCE);\n    planeLeft.rotateY(Math.PI / 2);\n    axis.add(planeLeft);\n    var textureBack = null;\n    materialBack = new THREE.MeshBasicMaterial({\n        map: textureBack,\n        side: THREE.DoubleSide\n    });\n    var planeBack = new THREE.Mesh(geometry, materialBack);\n    planeBack.position.setZ(DISTANCE);\n    planeBack.rotateY(-Math.PI);\n    axis.add(planeBack);\n    scene.add(axis);\n    var ambientLight = new THREE.AmbientLight(0xffffff, 0.5);\n    scene.add(ambientLight);\n    var pointLight = new THREE.PointLight(0xffffff, 1, 1000);\n    pointLight.position.set(50, 200, -100);\n    scene.add(pointLight);\n}\nfunction update() {\n    keyboard.update();\n    if (animateDirection === 0) {\n        if (keyboard.pressed(key.LEFT)) {\n            animateDirection = -1;\n            nextTexture = indexAt(currentTexture - 1);\n            materialBack.map = textureAt(nextTexture - 1);\n            materialBack.needsUpdate = true;\n        }\n        if (keyboard.pressed(key.RIGHT)) {\n            animateDirection = 1;\n            nextTexture = indexAt(currentTexture + 1);\n            materialBack.map = textureAt(nextTexture + 1);\n            materialBack.needsUpdate = true;\n        }\n    } else {\n        var distance = SPEED * animateDirection;\n        animateRotation += distance;\n        if (animateRotation < -Math.PI / 2 || animateRotation > Math.PI / 2) {\n            animateDirection = 0;\n            animateRotation = 0;\n            currentTexture = nextTexture;\n            nextTexture = 0;\n            materialLeft.map = textureAt(currentTexture - 1);\n            materialLeft.needsUpdate = true;\n            materialFront.map = textureAt(currentTexture);\n            materialFront.needsUpdate = true;\n            materialRight.map = textureAt(currentTexture + 1);\n            materialRight.needsUpdate = true;\n            materialBack.map = null;\n            materialBack.needsUpdate = true;\n            axis.rotation.y = 0;\n        } else {\n            axis.rotation.y += distance;\n        }\n    }\n// orbitControls.update();\n}\nfunction render() {\n    renderer.render(scene, camera);\n}\nfunction tick() {\n    update();\n    render();\n    requestAnimationFrame(tick);\n}\ninit();\ntick();\n\n\n//# sourceURL=webpack://three-experiments/./src/experiments/slides/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/experiments/slides/index.js"]();
/******/ 	
/******/ })()
;